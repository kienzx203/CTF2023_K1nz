# **Exploite python**

## **No ASCII characters?**

- Ở python 3.7 cho phép bạn sử dụng các ký tự in nghiêng để viết các biểu thức của mình, không phải là ascii. Chúng tôi đã mã hóa tải trọng của mình bằng cách sử dụng chữ in nghiêng trên trang web này. Bằng cách này, tải trọng của chúng tôi có thể vượt qua danh sách đen, dễ dàng thôi.

- [**Tool thực hiện kỹ thuật này**](https://lingojam.com/ItalicTextGenerator)

## **No built in functions?**

- Đây là phần phức tạp hơn của việc thoát khỏi pyjail. eval đặt biến `__buildins__` thành `None`, vì vậy, rất tiếc, chúng tôi không thể sử dụng các hàm dựng sẵn để đọc từ hệ thống tệp. Điều này có nghĩa là không mở, không có tệp thực thi, không có gì cả. Điều đó không sao, bởi vì chúng ta có thể sử dụng một mẹo nhỏ để truy cập các mô-đun khác mà không cần nhập chúng, cũng như không cần nội trang.

## **The Python Class Hierarchy - (Hệ thống phân cấp python)**

- Hệ thống phân cấp lớp python sẽ là cửa ngõ để chúng tôi truy cập các mô-đun khác, như `os`, vì vậy chúng tôi có thể đọc từ `Filesystem` hoặc lấy `Shell`. Vì vậy, làm thế nào để chúng tôi làm điều này? Chà, chúng ta sẽ cần học cách vượt qua hệ thống phân cấp lớp python. Đầu tiên, chúng ta hãy xem đoạn mã sau.

```python
().__class__
```

- Thuộc tính `__class__` có tác dụng trả về class của nó.Ví dụ sau đây:

![](./img_expy/Screenshot%202023-08-16%20002304.png)


- Thuộc tính `__base__` có tác dụng cho phép truy cập một lớp `cha` của một lớp.

- Thuộc tính `__subclasses__` có tác dụng tìm các lớp con kế thừa.

```python
print(().__class__.__base__.__subclasses__())
```

- Cách để chúng ta tìm ra các lớp kế thừa lớp Object.

![](./img_expy/Screenshot%202023-08-16%20011254.png)

## **From Class to Module**

- Chúng ta có thể truy cập các lớp từ các mô-đun khác thông qua các lớp con, nhưng làm cách nào để chúng ta truy cập các biến và hàm từ các mô-đun đó? Chà, hãy xem qua những gì `__globals__` làm và cách chúng ta có thể sử dụng nó.

- `__globals__` là một biến được xác định cho tất cả các chức năng. Nó là một từ điển chứa tất cả các biến và hàm trong phạm vi toàn cục có cùng phạm vi mô-đun với chính nó. Điều này có nghĩa là nếu chúng ta có thể lấy một hàm từ một lớp trong một mô-đun khác, thì chúng ta có thể truy cập phạm vi toàn cục của một mô-đun khác thông qua thuộc tính `__globals__` của hàm đó! Vậy… chúng ta có thể sử dụng những chức năng nào có trong tất cả các lớp? Chà, một chức năng có mặt trong tất cả các lớp bất kể chức năng hoặc thuộc tính của lớp đó là `__init__`.

![](./img_expy/Screenshot%202023-08-16%20012642.png)

## **No Strings?**

- Khai thác của chúng tôi ở trên yêu cầu chúng tôi sử dụng hai chuỗi. “popen” và “sh” đều cần thiết để khai thác của chúng tôi hoạt động! “popen” lấy chức năng popen từ từ điển `__globals__`, và “sh” là cần thiết để mở trình bao. Chắc chắn phải có một cách để không cần sử dụng chuỗi hoặc làm cho các chuỗi này không có dấu ngoặc kép?

```python
s = "I hate pyjails!"
s[7] + s[5] + s[7] + s[13] + s[11]
# -> 'pepsi'
().__doc__
# -> 'Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.'
().__doc__[19] + ().__doc__[56]
# -> 'sh'
().__class__.__base__.__subclasses__()[127].__init__.__globals__[().__doc__[84]+().__doc__[34]+().__doc__[84]+().__doc__[17]+().__doc__[7]](().__doc__[19]+().__doc__[56])
```

- Có lẽ chúng ta có thể sử dụng các chuỗi từ các thể hiện của các lớp để tạo một chuỗi bao gồm các chuỗi khác? Chà, những chuỗi nào có mặt trong các lớp? Chà, `__doc__`, tất nhiên rồi! `__doc__` là thuộc tính cung cấp tài liệu về một loại. Trong trường hợp này, chúng ta có thể tận dụng điều đó để tạo lợi thế cho mình.

## **No more than 102 characters?**

```python
().__class__.__base__.__subclasses__()[127].__init__.__globals__.values()
```