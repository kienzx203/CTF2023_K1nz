"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var serve_static_exports = {};
__export(serve_static_exports, {
  serveStatic: () => serveStatic
});
module.exports = __toCommonJS(serve_static_exports);
var import_fs = require("fs");
var import_filepath = require("hono/utils/filepath");
var import_mime = require("hono/utils/mime");
const createStreamBody = (stream) => {
  const body = new ReadableStream({
    start(controller) {
      stream.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      stream.on("end", () => {
        controller.close();
      });
    },
    cancel() {
      stream.destroy();
    }
  });
  return body;
};
const serveStatic = (options = { root: "" }) => {
  return async (c, next) => {
    if (c.finalized)
      return next();
    const url = new URL(c.req.url);
    const filename = options.path ?? decodeURIComponent(url.pathname);
    let path = (0, import_filepath.getFilePath)({
      filename: options.rewriteRequestPath ? options.rewriteRequestPath(filename) : filename,
      root: options.root,
      defaultDocument: options.index ?? "index.html"
    });
    if (!path)
      return next();
    path = `./${path}`;
    if (!(0, import_fs.existsSync)(path)) {
      return next();
    }
    const mimeType = (0, import_mime.getMimeType)(path);
    if (mimeType) {
      c.header("Content-Type", mimeType);
    }
    const stat = (0, import_fs.lstatSync)(path);
    const size = stat.size;
    if (c.req.method == "HEAD" || c.req.method == "OPTIONS") {
      c.header("Content-Length", size.toString());
      c.status(200);
      return c.body(null);
    }
    const range = c.req.header("range") || "";
    if (!range) {
      c.header("Content-Length", size.toString());
      return c.body(createStreamBody((0, import_fs.createReadStream)(path)), 200);
    }
    c.header("Accept-Ranges", "bytes");
    c.header("Date", stat.birthtime.toUTCString());
    let start = 0;
    let end = stat.size - 1;
    const parts = range.replace(/bytes=/, "").split("-");
    start = parseInt(parts[0], 10);
    end = parts[1] ? parseInt(parts[1], 10) : end;
    if (size < end - start + 1) {
      end = size - 1;
    }
    const chunksize = end - start + 1;
    const stream = (0, import_fs.createReadStream)(path, { start, end });
    c.header("Content-Length", chunksize.toString());
    c.header("Content-Range", `bytes ${start}-${end}/${stat.size}`);
    return c.body(createStreamBody(stream), 206);
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  serveStatic
});
